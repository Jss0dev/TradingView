//@version=6
indicator("카르마RSI", overlay=true, max_bars_back=500)

// ═══════════════════════════════════════════════════════════════
// [계산 입력값] CALC INPUTS
// ═══════════════════════════════════════════════════════════════

// 채널 설정
channelSettings = "Channel 설정"
int   channelLength        = input.int(120, "채널 길이", minval=2, maxval=500,group=channelSettings)
float channelWidth = input.float(1.5, "채널 폭", step=0.1, minval=0.1, group=channelSettings)
// RSI 설정
rsiSettings = "RSI 설정"
int   rsiLength         = input.int(14, "RSI 선 길이", minval=0, group=rsiSettings)
int   signalLineLength  = input.int(14, "시그널 선 길이", minval=0, group=rsiSettings)



// DIVERGENCE
groupDIV = "DIVERGENCE"
bool calc_div   = input.bool(false, "다이버전스 계산", group=groupDIV, tooltip="끄면 계산/표시/알림 모두 비활성")
int  lbLeft     = input.int(5,  "좌측 룩백",  minval=1, group=groupDIV, inline="lb")
int  lbRight    = input.int(5,  "우측 룩백",  minval=1, group=groupDIV, inline="lb")
int  rgLower    = input.int(5,  "범위 하한", minval=1, group=groupDIV, inline="rg")
int  rgUpper    = input.int(60, "범위 상한", minval=2, group=groupDIV, inline="rg")

// ═══════════════════════════════════════════════════════════════
// [스타일 입력값] STYLE INPUTS
// ═══════════════════════════════════════════════════════════════

// CHANNEL
channelStyle = "Cnannel 스타일"
bool  showOverBoughtLine   = input.bool(true, "과매수 라인", inline="과매수 라인", group=channelStyle)
color overBoughtLineColor  = input.color(#a7abb9, "", group=channelStyle, inline="과매수 라인")

bool  showMidLine      = input.bool(true, "중앙선", inline="중앙선", group=channelStyle)
color midLineColor     = input.color(color.gray, "", inline="중앙선", group=channelStyle)

bool  showOverSoldLine     = input.bool(true, "과매도 라인", inline = "과매도 라인", group=channelStyle)
color overSoldLineColor    = input.color(color.gray, "", group=channelStyle, inline = "과매도 라인")

bool  fillChannelBand  = input.bool(true, "백그라운드", inline="백그라운드", group=channelStyle)
color channelBandColor = input.color(color.olive, "", inline = "백그라운드", group=channelStyle)

// RSI
rsiStyle = "RSI 스타일"
bool showRsiLine        = input.bool(true, "RSI 선", inline = "RSI 선", group=rsiStyle)
color rsiLineColor      = input.color(color.purple, "", inline = "RSI 선", group=rsiStyle)
int rsiLineWidth        = input.int(3, "", minval=1, maxval=5, inline="RSI 선",group=rsiStyle)


bool  showSignalLine    = input.bool(true, "시그널 선", inline = "시그널 선", group=rsiStyle)
color signalLineColor   = input.color(color.rgb(255, 0, 0), "", inline = "시그널 선", group=rsiStyle)
int signalLineWidth     = input.int(2, "", minval=1, maxval=5, inline="시그널 선",group=rsiStyle)

labelStyle = "라벨 설정"
bool  showRsiThresholdLabels = input.bool(true, "RSI 라벨 표시", group=labelStyle)
bool  showRsiUpperThresholdLabels = showRsiThresholdLabels and showOverBoughtLine
bool  showRsiLowerThresholdLabels = showRsiThresholdLabels and showOverSoldLine

// DIVERGENCE (색상)
color colRegBull = color.new(color.green,  0)
color colRegBear = color.new(color.red,    0)
color colHidBull = color.new(color.teal,   0)
color colHidBear = color.new(color.orange, 0)

// ═══════════════════════════════════════════════════════════════
// [유틸 함수] UTILS
// ═══════════════════════════════════════════════════════════════
f_log_regression(src, len) =>
    // 로그 안전장치
    float ln  = math.log(math.max(src, 1e-10))

    // 표준 내부축(x_std = 0..len-1, 현재바 x_std=len-1)에서의 회귀값
    float y0  = ta.linreg(ln, len, 0)  // x_std = len-1 (현재)
    float y1  = ta.linreg(ln, len, 1)  // x_std = len-2 (1바 전)

    // 표준축의 계수 y = a*x_std + b
    float a   = y0 - y1                 // 기울기(로그 스페이스, 바당 변화)
    float b   = y0 - a * (len - 1)      // 절편

    // 당신의 per축(현재=1, 과거=len)으로 변환: per = len - x_std
    // y = s*per + c  가 되도록 s,c 산출
    float s   = -a
    float c   = a * len + b

    [s, c]    // (slope, intercept) — 호출부의 기존 reg_start/reg_end 식과 호환


// 최근 cond가 true였던 시점이 허용 범위 안인지 검사
f_inRange(cond, lo, hi) =>
    int bars = ta.barssince(cond)
    lo <= bars and bars <= hi

// ═══════════════════════════════════════════════════════════════
// [채널 계산] REGRESSION CHANNEL
// ═══════════════════════════════════════════════════════════════
bool  bar_ready   = bar_index >= channelLength - 1

float slope       = na
float intercept   = na
float reg_start   = na
float reg_end     = na
float dev         = na
float upper_start = na
float upper_end   = na
float lower_start = na
float lower_end   = na
float channelPercentChange = na

if bar_ready
    [slope, intercept] = f_log_regression(close, channelLength)
    reg_start   := math.exp(intercept + slope * channelLength)
    reg_end     := math.exp(intercept + slope * 1.0)
    dev         := ta.stdev(close, channelLength)
    upper_start := reg_start + dev * channelWidth
    upper_end   := reg_end   + dev * channelWidth
    lower_start := reg_start - dev * channelWidth
    lower_end   := reg_end   - dev * channelWidth
    // slope returned by f_log_regression is log(past/current)
    // compute percentage price change over the channel
    channelPercentChange := (reg_end - reg_start) / reg_start * 100

// 라인/필 핸들
var line     mid_line  = na
var line     upper_line = na
var line     lower_line = na
var linefill ch_fill    = na
var label    lblSlope   = na

// 채널 라인/필 업데이트
if bar_ready and not na(dev)
    // 중앙선
    if na(mid_line)
        mid_line := line.new(bar_index[channelLength], reg_start, bar_index, reg_end, xloc=xloc.bar_index, color=showMidLine ? midLineColor : na, style=line.style_dashed)
    else
        line.set_xy1(mid_line, bar_index[channelLength], reg_start)
        line.set_xy2(mid_line, bar_index,       reg_end)

    // 상/하단
    if na(upper_line)
        upper_line := line.new(bar_index[channelLength], upper_start, bar_index, upper_end, xloc=xloc.bar_index, color=showOverBoughtLine ? overBoughtLineColor : na, width=2)
    else
        line.set_xy1(upper_line, bar_index[channelLength], upper_start)
        line.set_xy2(upper_line, bar_index,         upper_end)

    if na(lower_line)
        lower_line := line.new(bar_index[channelLength], lower_start, bar_index, lower_end, xloc=xloc.bar_index, color=showOverSoldLine ? overSoldLineColor : na, width=2)
    else
        line.set_xy1(lower_line, bar_index[channelLength], lower_start)
        line.set_xy2(lower_line, bar_index,         lower_end)

    // 채움
    if fillChannelBand
        if na(ch_fill) and not na(upper_line) and not na(lower_line)
            ch_fill := linefill.new(upper_line, lower_line, channelBandColor)
    else
        if not na(ch_fill)
            linefill.delete(ch_fill)
            ch_fill := na

// 준비 미충족 시 정리
if not bar_ready or na(dev)
    if not na(mid_line)
        line.delete(mid_line),  mid_line  := na
    if not na(upper_line)
        line.delete(upper_line), upper_line := na
    if not na(lower_line)
        line.delete(lower_line), lower_line := na
    if not na(ch_fill)
        linefill.delete(ch_fill), ch_fill := na
    if not na(lblSlope)
        label.delete(lblSlope), lblSlope := na

// ═══════════════════════════════════════════════════════════════
// [RSI & 시그널] RSI / SIGNAL
// ═══════════════════════════════════════════════════════════════
float rsi = ta.rsi(close, rsiLength)
float sig = ta.sma(rsi,  signalLineLength)

int   rsiUpper = 70
int   rsiLower = 30

// 채널 축 ↔ RSI 매핑 준비
float lower_slope = na
float step        = na
if bar_ready and not na(dev)
    lower_slope := (lower_start - lower_end) / (channelLength - 1)
    step        := (upper_end   - lower_end) / (rsiUpper - rsiLower)


// RSI→가격 매핑 (idx: 0=현재..length-1=과거)
f_map_to_price_at(idx, r) =>
    float base = lower_end + lower_slope * idx
    base + step * (r - rsiLower)

// 폴리라인 핸들/라벨
var polyline pl_rsi = na
var polyline pl_sig = na
var label    lbl_rsi = na
var label    lbl_lo  = na
var label    lbl_hi  = na
var array<chart.point> points_rsi = array.new<chart.point>()
var array<chart.point> points_sig = array.new<chart.point>()

// 마지막 바에서만 폴리라인/라벨 갱신
if barstate.islast and bar_ready and not na(dev)
    // 정리
    if not na(pl_rsi)
        polyline.delete(pl_rsi), pl_rsi := na
    if not na(pl_sig)
        polyline.delete(pl_sig), pl_sig := na
    if not na(lbl_rsi)
        label.delete(lbl_rsi), lbl_rsi := na
    if not na(lbl_lo)
        label.delete(lbl_lo),  lbl_lo  := na
    if not na(lbl_hi)
        label.delete(lbl_hi),  lbl_hi  := na

    // RSI 폴리라인
    array.clear(points_rsi)
    for i = 0 to channelLength - 1
        float y = f_map_to_price_at(i, rsi[i])
        array.push(points_rsi, chart.point.from_index(bar_index[i], y))
    if showRsiLine
        pl_rsi := polyline.new(points_rsi, line_color=rsiLineColor, closed=false, force_overlay=true, line_width=rsiLineWidth)

    // 시그널 폴리라인
    if showSignalLine
        array.clear(points_sig)
        for i = 0 to channelLength - 1
            float yS = f_map_to_price_at(i, sig[i])
            array.push(points_sig, chart.point.from_index(bar_index[i], yS))
        pl_sig := polyline.new(points_sig, line_color=signalLineColor, closed=false, force_overlay=true, line_width=signalLineWidth)

    // 라벨
    float y_now = f_map_to_price_at(0, rsi)
    lbl_rsi := label.new(bar_index, (upper_end + lower_end) / 2, "카르마 RSI: " + str.tostring(rsi, "#.##"), style=label.style_label_left, textcolor=chart.fg_color, color=color.new(color.black, 100))

    if showRsiUpperThresholdLabels
        lbl_hi := label.new(bar_index, upper_end, str.tostring(rsiUpper, "##.#"), style=label.style_label_left, textcolor=chart.fg_color, color=color.new(color.black, 100))
    if showRsiLowerThresholdLabels
        lbl_lo := label.new(bar_index, lower_end, str.tostring(rsiLower, "##.#"), style=label.style_label_left, textcolor=chart.fg_color, color=color.new(color.black, 100))

    string slopeText = "기울기: " + str.format("{0,number,0.###}%", channelPercentChange)
    if na(lblSlope)
        lblSlope := label.new(bar_index, upper_end, slopeText, style = label.style_label_lower_right, textcolor=chart.fg_color, color=color.new(color.black, 100) )
    else
        label.set_xy(lblSlope, bar_index, upper_end)
        label.set_text(lblSlope, slopeText)

// ═══════════════════════════════════════════════════════════════
// [다이버전스 계산] DIVERGENCE CALC (Regular + Hidden)
// ═══════════════════════════════════════════════════════════════
bool regBull = false, regBear = false, hidBull = false, hidBear = false

if calc_div
    // 피벗
    bool plFound = not na(ta.pivotlow(rsi,  lbLeft,  lbRight))
    bool phFound = not na(ta.pivothigh(rsi, lbLeft,  lbRight))

    // 피벗 기준 바의 값 (우측 룩백)
    float rsiLBR  = rsi[lbRight]
    float lowLBR  = low[lbRight]
    float highLBR = high[lbRight]

    // 이전 피벗에서의 참조 값
    float prev_rsiL_of_PL  = ta.valuewhen(plFound, rsi[lbRight],  1)
    float prev_lowL_of_PL  = ta.valuewhen(plFound, low[lbRight],  1)
    float prev_rsiL_of_PH  = ta.valuewhen(phFound, rsi[lbRight],  1)
    float prev_highL_of_PH = ta.valuewhen(phFound, high[lbRight], 1)

    // Regular Bullish: Price LL & RSI HL (pivotlow)
    bool rsiHL   = not na(prev_rsiL_of_PL) and rsiLBR  > prev_rsiL_of_PL and f_inRange(plFound[1], rgLower, rgUpper)
    bool priceLL = not na(prev_lowL_of_PL) and lowLBR  < prev_lowL_of_PL
    regBull := plFound and rsiHL and priceLL

    // Hidden Bullish: Price HL & RSI LL (pivotlow)
    bool rsiLL   = not na(prev_rsiL_of_PL) and rsiLBR  < prev_rsiL_of_PL and f_inRange(plFound[1], rgLower, rgUpper)
    bool priceHL = not na(prev_lowL_of_PL) and lowLBR  > prev_lowL_of_PL
    hidBull := plFound and rsiLL and priceHL

    // Regular Bearish: Price HH & RSI LH (pivothigh)
    bool rsiLH   = not na(prev_rsiL_of_PH) and rsiLBR  < prev_rsiL_of_PH and f_inRange(phFound[1], rgLower, rgUpper)
    bool priceHH = not na(prev_highL_of_PH) and highLBR > prev_highL_of_PH
    regBear := phFound and rsiLH and priceHH

    // Hidden Bearish: Price LH & RSI HH (pivothigh)
    bool rsiHH   = not na(prev_rsiL_of_PH) and rsiLBR  > prev_rsiL_of_PH and f_inRange(phFound[1], rgLower, rgUpper)
    bool priceLH = not na(prev_highL_of_PH) and highLBR < prev_highL_of_PH
    hidBear := phFound and rsiHH and priceLH

// 다이버전스 마커용 좌표(전역 계산)
float y_div = na
if bar_ready and not na(dev)
    y_div := f_map_to_price_at(lbRight, rsi[lbRight])

// 플래그(표시 가능 여부)
bool canPlotDiv = calc_div and bar_ready and not na(dev)

// ═══════════════════════════════════════════════════════════════
// [다이버전스 표시/알림] (전역에서 호출: local scope 금지)
// ═══════════════════════════════════════════════════════════════
plotshape(canPlotDiv and regBull ? y_div : na, title="Regular Bullish", style=shape.labelup,   text="Reg Bull", color=colRegBull, textcolor=color.white, location=location.belowbar, offset=-lbRight)
plotshape(canPlotDiv and regBear ? y_div : na, title="Regular Bearish", style=shape.labeldown, text="Reg Bear", color=colRegBear, textcolor=color.white, location=location.abovebar, offset=-lbRight)
plotshape(canPlotDiv and hidBull ? y_div : na, title="Hidden Bullish",  style=shape.triangleup,   text="Hid Bull", color=colHidBull, textcolor=color.white, location=location.belowbar, offset=-lbRight)
plotshape(canPlotDiv and hidBear ? y_div : na, title="Hidden Bearish",  style=shape.triangledown, text="Hid Bear", color=colHidBear, textcolor=color.white, location=location.abovebar, offset=-lbRight)

// 알림
alertcondition(calc_div and regBull, title="KarmaRSI Regular Bullish", message="KarmaRSI: Regular Bullish Divergence")
alertcondition(calc_div and regBear, title="KarmaRSI Regular Bearish", message="KarmaRSI: Regular Bearish Divergence")
alertcondition(calc_div and hidBull, title="KarmaRSI Hidden Bullish",  message="KarmaRSI: Hidden Bullish Divergence")
alertcondition(calc_div and hidBear, title="KarmaRSI Hidden Bearish",  message="KarmaRSI: Hidden Bearish Divergence")
