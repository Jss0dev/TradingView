//@version=6
indicator("카르마RSI", overlay=true, max_bars_back=500)

// ═══════════════════════════════════════════════════════════════
// [입력값] INPUTS
// ═══════════════════════════════════════════════════════════════
// 채널
groupChannel = "CHANNEL"
int   length        = input.int(150, "채널 길이", minval=2, group=groupChannel)
float channelWidth  = input.float(1.5, "채널 폭", step=0.1, minval=0.1, group=groupChannel)

// 채널 기본 색상 (모습 탭에서 변경 가능)
color colUp  = #a7abb9
color colMid = color.gray
color colLow = #a7abb9

// RSI
groupRsi = "RSI"
int   lengthRsi        = input.int(14, "길이", inline="rsi", group=groupRsi)
color oscColBase       = input.color(color.rgb(161, 0, 182), "", inline="rsi", group=groupRsi)
int   rsiTransp        = input.int(30, "RSI 선 투명도 (0~100)", minval=0, maxval=100, group=groupRsi)
int   upperThreshold   = input.int(70, "상단 기준선 (%)", minval=50, maxval=100, step=1, inline="th", group=groupRsi)
bool  showThresholdLabels = input.bool(true, "기준선 라벨", inline="th", group=groupRsi)
bool  sigDisp          = input.bool(true, "Signal", inline="sig", group=groupRsi)
int   lengthSig        = input.int(14, "", inline="sig", group=groupRsi)
color sigLine          = input.color(color.rgb(255, 0, 0), "", inline="sig", group=groupRsi)

// ═══════════════════════════════════════════════════════════════
// 계산 로직
// ═══════════════════════════════════════════════════════════════
// 로그 회귀 함수
fLogRegression(src, len) =>
    // 최근 len개 구간: i=0(현재) ~ i=len-1(과거)
    float sumX = 0.0, sumY = 0.0, sumXSqr = 0.0, sumXY = 0.0
    for i = 0 to len - 1
        float per = i + 1.0
        float val = math.log(src[i])
        sumX += per
        sumY += val
        sumXSqr += per * per
        sumXY += val * per
    float slope = (len * sumXY - sumX * sumY) / (len * sumXSqr - sumX * sumX)
    float intercept = (sumY - slope * sumX) / len
    [slope, intercept]

// 현재 bar에서 len 구간이 충분한지
bool barReady = bar_index >= length

// 회귀선 및 채널 계산(충분한 바가 있어야 함)
float slope = na
float intercept = na
float regStart = na
float regEnd = na
float dev = na
float upperStart = na
float upperEnd = na
float lowerStart = na
float lowerEnd = na

if barReady
    [slope, intercept] = fLogRegression(close, length)  // ← 다중 할당은 '=' 사용
    // per 를 1..length 로 잡았으므로,
    // start(과거) = per=length, end(현재) = per=1
    regStart := math.exp(intercept + slope * length)
    regEnd   := math.exp(intercept + slope * 1.0)
    dev := ta.stdev(close, length)
    upperStart := regStart + dev * channelWidth
    upperEnd   := regEnd   + dev * channelWidth
    lowerStart := regStart - dev * channelWidth
    lowerEnd   := regEnd   - dev * channelWidth

// RSI & 시그널
float rsi = ta.rsi(close, lengthRsi)
float sig = ta.sma(rsi,  lengthSig)
int   lowerThreshold = 100 - upperThreshold

// 채널 축 ↔ RSI(0~100) 매핑
// - 각 bar에서 하단 기준선 값: lowerEnd(현재)에서 과거로 갈수록 선형 보간
float lowerSlope = na
float step = na
if barReady and not na(dev)
    lowerSlope := (lowerStart - lowerEnd) / (length - 1)
    step       := (upperEnd   - lowerEnd) / (upperThreshold - lowerThreshold)  // 1 RSI 포인트당 가격 변화량

// 매핑 함수 (파라미터 타입 기입/ '=' 금지)
fMapToPriceAt(idx, r) =>
    // idx: i=0(현재) .. i=length-1(과거)
    float base = lowerEnd + lowerSlope * idx
    base + step * (r - lowerThreshold)

// ═══════════════════════════════════════════════════════════════
// 모습
// ═══════════════════════════════════════════════════════════════
color oscCol = color.new(oscColBase, rsiTransp)
var polyline plRsi = na
var polyline plSig = na

var label lblRsi = na
var label lblLo  = na
var label lblHi  = na

// 채널 플롯 (모습 탭 제어)
float upperSeries = barReady and not na(dev) ? upperEnd : na
float midSeries   = barReady and not na(dev) ? regEnd   : na
float lowerSeries = barReady and not na(dev) ? lowerEnd : na

plotUpper = plot(upperSeries, title="Upper", color=colUp,  linewidth=2)
plotLower = plot(lowerSeries, title="Lower", color=colLow, linewidth=2)
plotMid   = plot(midSeries,   title="Mid",   color=colMid)
fill(plotUpper, plotLower, color=color.new(oscColBase, 95), title="Channel Fill")

// 폴리라인 & 라벨(마지막 바에서만 재그리기 → 성능/누수 관리)
if barstate.islast and barReady and not na(dev)
    // 이전 도형/라벨 정리 (각 문장 분리)
    if not na(plRsi)
        polyline.delete(plRsi)
        plRsi := na
    if not na(plSig)
        polyline.delete(plSig)
        plSig := na
    if not na(lblRsi)
        label.delete(lblRsi)
        lblRsi := na
    if not na(lblLo)
        label.delete(lblLo)
        lblLo := na
    if not na(lblHi)
        label.delete(lblHi)
        lblHi := na

    // RSI 폴리라인
    pointsRsi = array.new<chart.point>()
    for i = 0 to length - 1
        float y = fMapToPriceAt(i, rsi[i])
        array.push(pointsRsi, chart.point.from_index(bar_index[i], y))
    plRsi := polyline.new(pointsRsi, line_color=oscCol, closed=false, force_overlay=true, line_width=4)

    // Signal 폴리라인 (옵션)
    if sigDisp
        pointsSig = array.new<chart.point>()
        for i = 0 to length - 1
            float yS = fMapToPriceAt(i, sig[i])
            array.push(pointsSig, chart.point.from_index(bar_index[i], yS))
        plSig := polyline.new(pointsSig, line_color=sigLine, closed=false, force_overlay=true, line_width=2)

    // 라벨: 현재값/기준선 (옵션)
    float yNow = fMapToPriceAt(0, rsi)
    lblRsi := label.new(bar_index, yNow,
         "카르마 RSI: " + str.tostring(rsi, "#.##"),
         style=label.style_label_left, textcolor=chart.fg_color, color=color.new(color.black, 100))

    if showThresholdLabels
        lblLo := label.new(bar_index, lowerEnd, str.tostring(lowerThreshold, "##.#"), style=label.style_label_left, textcolor=chart.fg_color, color=color.new(color.black, 100))
        lblHi := label.new(bar_index, upperEnd, str.tostring(upperThreshold, "##.#"), style=label.style_label_left, textcolor=chart.fg_color, color=color.new(color.black, 100))
